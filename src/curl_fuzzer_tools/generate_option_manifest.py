#!/usr/bin/env python3
"""
Regenerate option manifest artefacts from the supported CURLOPT list.

This script reads a plain-text list of supported CURLOPT identifiers, looks up
metadata in curl.h to determine each option's numeric value and value kind, and
then emits two artefacts:

* generated/curl_fuzzer_option_manifest.inc – consumed by the runtime harness.
* schemas/curl_fuzzer.proto – the CurlOptionId enum gains the native values.

It replaces the previous YAML-driven flow with an approach that derives type and
numeric identifiers directly from curl.h so that we remain in sync with the
upstream library.
"""
from __future__ import annotations

import dataclasses
import pathlib
import re
from typing import Dict, Iterable, List

REPO_ROOT = pathlib.Path(__file__).resolve().parents[2]
SUPPORTED_LIST = REPO_ROOT / "schemas" / "curl_fuzzer_supported_curlopts.txt"
CURL_HEADER = REPO_ROOT / "build" / "curl-install" / "include" / "curl" / "curl.h"
PROTO_FILE = REPO_ROOT / "schemas" / "curl_fuzzer.proto"
MANIFEST_FILE = REPO_ROOT / "generated" / "curl_fuzzer_option_manifest.inc"

TYPE_BASE_VALUES: Dict[str, int] = {
    "CURLOPTTYPE_LONG": 0,
    "CURLOPTTYPE_VALUES": 0,
    "CURLOPTTYPE_OBJECTPOINT": 10000,
    "CURLOPTTYPE_STRINGPOINT": 10000,
    "CURLOPTTYPE_SLISTPOINT": 10000,
    "CURLOPTTYPE_CBPOINT": 10000,
    "CURLOPTTYPE_FUNCTIONPOINT": 20000,
    "CURLOPTTYPE_OFF_T": 30000,
    "CURLOPTTYPE_BLOB": 40000,
}

BASE_KIND: Dict[str, str] = {
    "CURLOPTTYPE_LONG": "uint32",
    "CURLOPTTYPE_VALUES": "uint32",
    "CURLOPTTYPE_STRINGPOINT": "string",
    # The remaining pointer-based families require explicit overrides.
    "CURLOPTTYPE_OBJECTPOINT": "unknown",
    "CURLOPTTYPE_SLISTPOINT": "unknown",
    "CURLOPTTYPE_CBPOINT": "unknown",
    "CURLOPTTYPE_FUNCTIONPOINT": "unknown",
    "CURLOPTTYPE_BLOB": "unknown",
    "CURLOPTTYPE_OFF_T": "uint64",
}

OPTION_KIND_OVERRIDES: Dict[str, str] = {
    # Pointers that are treated as specialised structs.
    "CURLOPT_HTTPPOST": "http_post",
    "CURLOPT_MIMEPOST": "mime",
    # Object pointers that hold string-like data.
    "CURLOPT_POSTFIELDS": "string",
    # Historically modelled as booleans although libcurl exposes them as long.
    "CURLOPT_UPLOAD": "bool",
}

VALUE_KIND_SYMBOLS: Dict[str, str] = {
    "string": "OptionValueKind::kString",
    "uint32": "OptionValueKind::kUint32",
    "uint64": "OptionValueKind::kUint64",
    "bool": "OptionValueKind::kBool",
    "http_post": "OptionValueKind::kHttpPost",
    "mime": "OptionValueKind::kMime",
    "unknown": "OptionValueKind::kUnknown",
}


@dataclasses.dataclass(frozen=True)
class CurlOption:
    name: str
    type_token: str
    curl_value: int

    @property
    def manifest_kind(self) -> str:
        base_kind = BASE_KIND.get(self.type_token)
        kind = OPTION_KIND_OVERRIDES.get(self.name, base_kind)
        if kind is None or kind == "unknown":
            raise ValueError(
                f"Unsupported type mapping for {self.name}: {self.type_token}. "
                "Please extend OPTION_KIND_OVERRIDES or BASE_KIND."
            )
        return kind


def load_supported_options(path: pathlib.Path) -> List[str]:
    if not path.exists():
        raise FileNotFoundError(f"Supported options list missing: {path}")
    options: List[str] = []
    for raw_line in path.read_text().splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        options.append(line)
    if not options:
        raise ValueError(f"No options found in {path}")
    return options


def parse_curl_header(path: pathlib.Path) -> Dict[str, CurlOption]:
    if not path.exists():
        raise FileNotFoundError(f"curl.h not found at {path}")
    text = path.read_text()
    pattern = re.compile(
        r"CURLOPT(?:DEPRECATED)?\(\s*(CURLOPT_[A-Z0-9_]+)\s*,\s*(CURLOPTTYPE_[A-Z0-9_]+)\s*,\s*([0-9]+)",
        re.MULTILINE,
    )
    options: Dict[str, CurlOption] = {}
    for match in pattern.finditer(text):
        name, type_token, offset_text = match.groups()
        if type_token not in TYPE_BASE_VALUES:
            raise ValueError(f"Unknown CURLOPT type token: {type_token} for {name}")
        base_value = TYPE_BASE_VALUES[type_token]
        offset = int(offset_text)
        options[name] = CurlOption(name=name, type_token=type_token, curl_value=base_value + offset)
    if not options:
        raise ValueError("Failed to extract any CURLOPT definitions from curl.h")
    return options


def emit_manifest(entries: Iterable[CurlOption]) -> str:
    lines = [
        "// Generated by src/curl_fuzzer_tools/generate_option_manifest.py",
        "static constexpr OptionDescriptor kOptionManifest[] = {",
    ]
    for option in entries:
        kind_symbol = VALUE_KIND_SYMBOLS[option.manifest_kind]
        lines.append(
            f"    {{curl::fuzzer::proto::{option.name}, {kind_symbol}, true, \"{option.name}\", {option.name}}},"
        )
    lines.append("};")
    lines.append(
        "static constexpr size_t kOptionManifestSize = sizeof(kOptionManifest) / sizeof(kOptionManifest[0]);"
    )
    return "\n".join(lines) + "\n"


def rewrite_proto(entries: Iterable[CurlOption], proto_path: pathlib.Path) -> None:
    text = proto_path.read_text()
    enum_marker = "enum CurlOptionId"
    start_idx = text.find(enum_marker)
    if start_idx == -1:
        raise ValueError("Unable to locate CurlOptionId enum in curl_fuzzer.proto")
    brace_idx = text.find("{", start_idx)
    if brace_idx == -1:
        raise ValueError("Malformed CurlOptionId enum definition")
    depth = 1
    idx = brace_idx + 1
    while idx < len(text) and depth > 0:
        char = text[idx]
        if char == "{":
            depth += 1
        elif char == "}":
            depth -= 1
        idx += 1
    if depth != 0:
        raise ValueError("Unbalanced braces when parsing CurlOptionId enum")
    closing_idx = idx - 1  # Position of the closing brace

    indent = "  "
    enum_lines = [f"{indent}CURL_OPTION_UNSPECIFIED = 0;"]
    enum_lines.extend(
        f"{indent}{option.name} = {option.curl_value};" for option in entries
    )
    enum_body = "\n".join(enum_lines) + "\n"

    new_text = text[: brace_idx + 1] + "\n" + enum_body + text[closing_idx:]
    proto_path.write_text(new_text)


def main() -> int:
    supported = load_supported_options(SUPPORTED_LIST)
    header_options = parse_curl_header(CURL_HEADER)

    ordered_entries: List[CurlOption] = []
    for name in supported:
        if name not in header_options:
            raise KeyError(f"CURLOPT {name} not found in curl.h")
        ordered_entries.append(header_options[name])

    MANIFEST_FILE.write_text(emit_manifest(ordered_entries))
    rewrite_proto(ordered_entries, PROTO_FILE)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
